import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
from matplotlib.patches import Rectangle
import warnings
warnings.filterwarnings('ignore')

# Thi·∫øt l·∫≠p style cho matplotlib
plt.style.use('seaborn-v0_8')
sns.set_palette("husl")

class NV_TC_ResultsVisualizer:
    """
    L·ªõp tr·ª±c quan h√≥a k·∫øt qu·∫£ t·ªëi ∆∞u h√≥a t·∫≠p trung v√†o 2 ti√™u ch√≠: NV (S·ªë xe) v√† TC (Chi ph√≠ t·ªïng)
    """
    
    def __init__(self, excel_file="20250731_155756_optimization_results.xlsx"):
        """
        Kh·ªüi t·∫°o v√† ƒë·ªçc d·ªØ li·ªáu t·ª´ file Excel ch·ªâ c√≥ NV v√† TC
        """
        self.excel_file = excel_file
        self.df_raw = None
        self.df_clean = None
        self.load_data()
        
    def load_data(self):
        """
        ƒê·ªçc v√† x·ª≠ l√Ω d·ªØ li·ªáu t·ª´ file Excel v·ªõi c·∫•u tr√∫c multi-level headers
        """
        try:
            # ƒê·ªçc file Excel v·ªõi header ƒëa c·∫•p
            self.df_raw = pd.read_excel(self.excel_file, sheet_name=0, header=[0, 1])
            
            # L√†m ph·∫≥ng multi-level columns
            self.df_raw.columns = ['_'.join(col).strip() if col[1] != '' else col[0] 
                                  for col in self.df_raw.columns.values]
            
            # T·∫°o b·∫£n sao v√† l√†m s·∫°ch d·ªØ li·ªáu
            self.df_clean = self.df_raw.copy()
            
            # ƒê·ªïi t√™n c·ªôt ƒë·ªÉ d·ªÖ s·ª≠ d·ª•ng
            column_mapping = {}
            for col in self.df_clean.columns:
                if 'Instance' in col:
                    column_mapping[col] = 'Instance'
                elif 'Algorithm' in col:
                    column_mapping[col] = 'Algorithm'
                elif 'NV_Min' in col or ('NV' in col and 'Min' in col):
                    column_mapping[col] = 'NV_Min'
                elif 'NV_Std' in col or ('NV' in col and 'Std' in col):
                    column_mapping[col] = 'NV_Std'
                elif 'NV_Mean' in col or ('NV' in col and 'Mean' in col):
                    column_mapping[col] = 'NV_Mean'
                elif 'TC_Min' in col or ('TC' in col and 'Min' in col):
                    column_mapping[col] = 'TC_Min'
                elif 'TC_Std' in col or ('TC' in col and 'Std' in col):
                    column_mapping[col] = 'TC_Std'
                elif 'TC_Mean' in col or ('TC' in col and 'Mean' in col):
                    column_mapping[col] = 'TC_Mean'
                elif 'Time' in col:
                    column_mapping[col] = 'Time_ms'
            
            self.df_clean = self.df_clean.rename(columns=column_mapping)
            
            # Lo·∫°i b·ªè c√°c d√≤ng tr·ªëng ho·∫∑c header ph·ª•
            self.df_clean = self.df_clean.dropna(subset=['Instance', 'Algorithm'])
            
            # √âp ki·ªÉu s·ªë cho c√°c c·ªôt s·ªë
            numeric_columns = ['NV_Min', 'NV_Std', 'NV_Mean', 'TC_Min', 'TC_Std', 'TC_Mean', 'Time_ms']
            for col in numeric_columns:
                if col in self.df_clean.columns:
                    # X·ª≠ l√Ω d·∫•u ph·∫©y trong s·ªë (n·∫øu c√≥)
                    if self.df_clean[col].dtype == 'object':
                        self.df_clean[col] = self.df_clean[col].astype(str).str.replace(',', '.')
                    self.df_clean[col] = pd.to_numeric(self.df_clean[col], errors='coerce')
            
            # Lo·∫°i b·ªè c√°c d√≤ng c√≥ gi√° tr·ªã NaN trong c√°c c·ªôt quan tr·ªçng
            self.df_clean = self.df_clean.dropna(subset=['NV_Mean', 'TC_Mean'])
            
            print(f"‚úÖ ƒê√£ t·∫£i th√†nh c√¥ng {len(self.df_clean)} d√≤ng d·ªØ li·ªáu")
            print(f"üìä C√°c instance: {self.df_clean['Instance'].unique()}")
            print(f"üîß C√°c thu·∫≠t to√°n: {self.df_clean['Algorithm'].unique()}")
            print(f"üìã C√°c c·ªôt d·ªØ li·ªáu: {list(self.df_clean.columns)}")
            
        except Exception as e:
            print(f"‚ùå L·ªói khi ƒë·ªçc file: {e}")
            # Th·ª≠ ph∆∞∆°ng ph√°p ƒë·ªçc ƒë∆°n gi·∫£n h∆°n
            try:
                print("üîÑ ƒêang th·ª≠ ph∆∞∆°ng ph√°p ƒë·ªçc kh√°c...")
                self.df_raw = pd.read_excel(self.excel_file, sheet_name=0)
                self.df_clean = self.df_raw.copy()
                
                # ƒê·∫∑t t√™n c·ªôt th·ªß c√¥ng d·ª±a tr√™n c·∫•u tr√∫c m√¥ t·∫£
                expected_columns = ['Instance', 'Algorithm', 'NV_Min', 'NV_Std', 'NV_Mean', 
                                  'TC_Min', 'TC_Std', 'TC_Mean', 'Time_ms']
                
                if len(self.df_clean.columns) == len(expected_columns):
                    self.df_clean.columns = expected_columns
                else:
                    print(f"‚ö†Ô∏è S·ªë c·ªôt kh√¥ng kh·ªõp. C√≥ {len(self.df_clean.columns)} c·ªôt, mong ƒë·ª£i {len(expected_columns)}")
                    print(f"C√°c c·ªôt hi·ªán t·∫°i: {list(self.df_clean.columns)}")
                
                # X·ª≠ l√Ω d·ªØ li·ªáu
                numeric_columns = ['NV_Min', 'NV_Std', 'NV_Mean', 'TC_Min', 'TC_Std', 'TC_Mean', 'Time_ms']
                for col in numeric_columns:
                    if col in self.df_clean.columns:
                        if self.df_clean[col].dtype == 'object':
                            self.df_clean[col] = self.df_clean[col].astype(str).str.replace(',', '.')
                        self.df_clean[col] = pd.to_numeric(self.df_clean[col], errors='coerce')
                
                self.df_clean = self.df_clean.dropna(subset=['Instance', 'Algorithm'])
                print(f"‚úÖ ƒê√£ t·∫£i th√†nh c√¥ng {len(self.df_clean)} d√≤ng d·ªØ li·ªáu (ph∆∞∆°ng ph√°p 2)")
                
            except Exception as e2:
                print(f"‚ùå L·ªói ph∆∞∆°ng ph√°p 2: {e2}")
                self.df_clean = pd.DataFrame()  # T·∫°o DataFrame r·ªóng
    
    def check_data_availability(self):
        """
        Ki·ªÉm tra t√≠nh kh·∫£ d·ª•ng c·ªßa d·ªØ li·ªáu
        """
        if self.df_clean is None or self.df_clean.empty:
            print("‚ùå Kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ x·ª≠ l√Ω!")
            return False
        
        required_columns = ['NV_Mean', 'TC_Mean']
        missing_columns = [col for col in required_columns if col not in self.df_clean.columns]
        
        if missing_columns:
            print(f"‚ùå Thi·∫øu c√°c c·ªôt quan tr·ªçng: {missing_columns}")
            return False
        
        return True
    
    def plot_nv_tc_comparison(self, instance=None, save_fig=True):
        """
        So s√°nh NV v√† TC cho m·ªôt instance c·ª• th·ªÉ ho·∫∑c t·∫•t c·∫£
        """
        if not self.check_data_availability():
            return
            
        if instance:
            subset = self.df_clean[self.df_clean['Instance'] == instance]
            title_suffix = f"cho {instance}"
        else:
            subset = self.df_clean
            title_suffix = "cho t·∫•t c·∫£ instances"
            
        if subset.empty:
            print(f"‚ùå Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu cho instance: {instance}")
            return
            
        fig, axes = plt.subplots(2, 2, figsize=(15, 12))
        fig.suptitle(f'üöõüí∞ So s√°nh NV v√† TC {title_suffix}', fontsize=16, fontweight='bold')
        
        # 1. Bi·ªÉu ƒë·ªì c·ªôt so s√°nh NV
        ax1 = axes[0, 0]
        nv_data = subset.groupby('Algorithm')['NV_Mean'].mean().sort_values()
        bars1 = ax1.bar(range(len(nv_data)), nv_data.values, 
                       color=sns.color_palette("Blues_r", len(nv_data)))
        ax1.set_title('üöõ S·ªë xe trung b√¨nh theo thu·∫≠t to√°n')
        ax1.set_xlabel('Thu·∫≠t to√°n')
        ax1.set_ylabel('S·ªë xe trung b√¨nh')
        ax1.set_xticks(range(len(nv_data)))
        ax1.set_xticklabels(nv_data.index, rotation=45)
        
        # Th√™m gi√° tr·ªã l√™n c·ªôt
        for i, bar in enumerate(bars1):
            height = bar.get_height()
            ax1.text(bar.get_x() + bar.get_width()/2., height + height*0.01,
                    f'{height:.1f}', ha='center', va='bottom')
        
        # 2. Bi·ªÉu ƒë·ªì c·ªôt so s√°nh TC
        ax2 = axes[0, 1]
        tc_data = subset.groupby('Algorithm')['TC_Mean'].mean().sort_values()
        bars2 = ax2.bar(range(len(tc_data)), tc_data.values, 
                       color=sns.color_palette("Reds_r", len(tc_data)))
        ax2.set_title('üí∞ Chi ph√≠ t·ªïng trung b√¨nh theo thu·∫≠t to√°n')
        ax2.set_xlabel('Thu·∫≠t to√°n')
        ax2.set_ylabel('Chi ph√≠ t·ªïng trung b√¨nh')
        ax2.set_xticks(range(len(tc_data)))
        ax2.set_xticklabels(tc_data.index, rotation=45)
        
        # Th√™m gi√° tr·ªã l√™n c·ªôt
        for i, bar in enumerate(bars2):
            height = bar.get_height()
            ax2.text(bar.get_x() + bar.get_width()/2., height + height*0.01,
                    f'{height:.0f}', ha='center', va='bottom')
        
        # 3. Scatter plot: NV vs TC
        ax3 = axes[1, 0]
        for alg in subset['Algorithm'].unique():
            alg_data = subset[subset['Algorithm'] == alg]
            ax3.scatter(alg_data['NV_Mean'], alg_data['TC_Mean'], 
                       label=alg, alpha=0.7, s=80)
        ax3.set_title('üìä M·ªëi quan h·ªá gi·ªØa S·ªë xe v√† Chi ph√≠')
        ax3.set_xlabel('S·ªë xe trung b√¨nh')
        ax3.set_ylabel('Chi ph√≠ t·ªïng trung b√¨nh')
        ax3.legend()
        ax3.grid(True, alpha=0.3)
        
        # 4. Heatmap t∆∞∆°ng quan NV-TC
        ax4 = axes[1, 1]
        if 'NV_Mean' in subset.columns and 'TC_Mean' in subset.columns:
            corr_data = subset[['NV_Mean', 'TC_Mean']].corr()
            sns.heatmap(corr_data, annot=True, cmap='coolwarm', center=0, ax=ax4,
                       square=True, linewidths=0.5)
            ax4.set_title('üî• Ma tr·∫≠n t∆∞∆°ng quan NV-TC')
        
        plt.tight_layout()
        
        if save_fig:
            filename = f"nv_tc_comparison_{instance if instance else 'all'}.png"
            plt.savefig(filename, dpi=300, bbox_inches='tight')
            print(f"üíæ ƒê√£ l∆∞u bi·ªÉu ƒë·ªì: {filename}")
        
        plt.show()
    
    def plot_algorithm_nv_tc_performance(self, save_fig=True):
        """
        Ph√¢n t√≠ch hi·ªáu su·∫•t NV v√† TC c·ªßa c√°c thu·∫≠t to√°n
        """
        if not self.check_data_availability():
            return
        fig, axes = plt.subplots(2, 3, figsize=(18, 12))
        fig.suptitle('üöÄ Ph√¢n t√≠ch hi·ªáu su·∫•t NV-TC theo thu·∫≠t to√°n', fontsize=16, fontweight='bold')
        
        # 1. Boxplot NV theo thu·∫≠t to√°n
        ax1 = axes[0, 0]
        sns.boxplot(data=self.df_clean, x='Algorithm', y='NV_Mean', ax=ax1)
        ax1.set_title('üì¶ Ph√¢n ph·ªëi s·ªë xe theo thu·∫≠t to√°n')
        ax1.set_xlabel('Thu·∫≠t to√°n')
        ax1.set_ylabel('S·ªë xe')
        ax1.tick_params(axis='x', rotation=45)
        
        # 2. Boxplot TC theo thu·∫≠t to√°n
        ax2 = axes[0, 1]
        sns.boxplot(data=self.df_clean, x='Algorithm', y='TC_Mean', ax=ax2)
        ax2.set_title('üì¶ Ph√¢n ph·ªëi chi ph√≠ theo thu·∫≠t to√°n')
        ax2.set_xlabel('Thu·∫≠t to√°n')
        ax2.set_ylabel('Chi ph√≠ t·ªïng')
        ax2.tick_params(axis='x', rotation=45)
        
        # 3. Violin plot k·∫øt h·ª£p NV v√† TC
        ax3 = axes[0, 2]
        melted_data = self.df_clean.melt(id_vars=['Algorithm', 'Instance'], 
                                        value_vars=['NV_Mean', 'TC_Mean'],
                                        var_name='Metric', value_name='Value')
        sns.violinplot(data=melted_data, x='Algorithm', y='Value', hue='Metric', ax=ax3)
        ax3.set_title('üéª Ph√¢n ph·ªëi m·∫≠t ƒë·ªô NV-TC')
        ax3.set_xlabel('Thu·∫≠t to√°n')
        ax3.set_ylabel('Gi√° tr·ªã')
        ax3.tick_params(axis='x', rotation=45)
        
        # 4. Scatter plot v·ªõi size theo NV, color theo TC
        ax4 = axes[1, 0]
        scatter = ax4.scatter(self.df_clean['NV_Mean'], self.df_clean['TC_Mean'], 
                            c=self.df_clean['TC_Mean'], s=self.df_clean['NV_Mean']*20, 
                            alpha=0.6, cmap='viridis')
        ax4.set_title('üéØ NV vs TC (K√≠ch th∆∞·ªõc = NV, M√†u = TC)')
        ax4.set_xlabel('S·ªë xe trung b√¨nh')
        ax4.set_ylabel('Chi ph√≠ t·ªïng trung b√¨nh')
        plt.colorbar(scatter, ax=ax4, label='Chi ph√≠ t·ªïng')
        
        # 5. Hi·ªáu qu·∫£ t·ªïng h·ª£p NV-TC
        ax5 = axes[1, 1]
        # Chu·∫©n h√≥a NV v√† TC (lower is better)
        normalized_data = self.df_clean.copy()
        normalized_data['NV_norm'] = (normalized_data['NV_Mean'] - normalized_data['NV_Mean'].min()) / \
                                    (normalized_data['NV_Mean'].max() - normalized_data['NV_Mean'].min())
        normalized_data['TC_norm'] = (normalized_data['TC_Mean'] - normalized_data['TC_Mean'].min()) / \
                                    (normalized_data['TC_Mean'].max() - normalized_data['TC_Mean'].min())
        
        # ƒêi·ªÉm hi·ªáu qu·∫£ t·ªïng h·ª£p (tr·ªçng s·ªë b·∫±ng nhau)
        normalized_data['Efficiency_Score'] = (normalized_data['NV_norm'] + normalized_data['TC_norm']) / 2
        
        efficiency = normalized_data.groupby('Algorithm')['Efficiency_Score'].mean().sort_values()
        bars5 = ax5.bar(range(len(efficiency)), efficiency.values, 
                       color=sns.color_palette("rocket", len(efficiency)))
        ax5.set_title('üéØ ƒêi·ªÉm hi·ªáu qu·∫£ NV-TC t·ªïng h·ª£p')
        ax5.set_xlabel('Thu·∫≠t to√°n')
        ax5.set_ylabel('ƒêi·ªÉm hi·ªáu qu·∫£ (th·∫•p h∆°n = t·ªët h∆°n)')
        ax5.set_xticks(range(len(efficiency)))
        ax5.set_xticklabels(efficiency.index, rotation=45)
        
        # Th√™m gi√° tr·ªã l√™n c·ªôt
        for i, bar in enumerate(bars5):
            height = bar.get_height()
            ax5.text(bar.get_x() + bar.get_width()/2., height + height*0.01,
                    f'{height:.3f}', ha='center', va='bottom')
        
        # 6. Radar chart cho thu·∫≠t to√°n t·ªët nh·∫•t
        ax6 = axes[1, 2]
        best_alg = efficiency.index[0]  # Thu·∫≠t to√°n c√≥ ƒëi·ªÉm hi·ªáu qu·∫£ th·∫•p nh·∫•t
        best_data = self.df_clean[self.df_clean['Algorithm'] == best_alg]
        
        # T√≠nh c√°c th·ªëng k√™ cho radar chart
        categories = ['NV_Mean', 'NV_Min', 'TC_Mean', 'TC_Min']
        values = []
        for cat in categories:
            if cat in best_data.columns:
                values.append(best_data[cat].mean())
            else:
                values.append(0)
        
        # Chu·∫©n h√≥a gi√° tr·ªã cho radar chart
        max_vals = []
        for cat in categories:
            if cat in self.df_clean.columns:
                max_vals.append(self.df_clean[cat].max())
            else:
                max_vals.append(1)
        
        normalized_values = [val/max_val if max_val != 0 else 0 for val, max_val in zip(values, max_vals)]
        
        angles = np.linspace(0, 2*np.pi, len(categories), endpoint=False).tolist()
        normalized_values += normalized_values[:1]  # ƒê√≥ng v√≤ng tr√≤n
        angles += angles[:1]
        
        ax6.plot(angles, normalized_values, 'o-', linewidth=2, label=best_alg)
        ax6.fill(angles, normalized_values, alpha=0.25)
        ax6.set_xticks(angles[:-1])
        ax6.set_xticklabels(categories)
        ax6.set_title(f'üéØ Profile thu·∫≠t to√°n t·ªët nh·∫•t: {best_alg}')
        ax6.grid(True)
        ax6.set_ylim(0, 1)
        
        plt.tight_layout()
        
        if save_fig:
            filename = "nv_tc_algorithm_performance.png"
            plt.savefig(filename, dpi=300, bbox_inches='tight')
            print(f"üíæ ƒê√£ l∆∞u bi·ªÉu ƒë·ªì: {filename}")
        
        plt.show()
    
    def plot_instance_nv_tc_analysis(self, save_fig=True):
        """
        Ph√¢n t√≠ch NV v√† TC theo t·ª´ng instance
        """
        if not self.check_data_availability():
            return
        instances = self.df_clean['Instance'].unique()
        
        fig, axes = plt.subplots(2, 2, figsize=(16, 12))
        fig.suptitle('üìã Ph√¢n t√≠ch NV-TC theo Instance', fontsize=16, fontweight='bold')
        
        # 1. Heatmap NV theo instance v√† thu·∫≠t to√°n
        ax1 = axes[0, 0]
        pivot_nv = self.df_clean.pivot_table(values='NV_Mean', index='Instance', 
                                            columns='Algorithm', aggfunc='mean')
        sns.heatmap(pivot_nv, annot=True, fmt='.1f', cmap='Blues', ax=ax1)
        ax1.set_title('üöõ S·ªë xe trung b√¨nh theo Instance & Thu·∫≠t to√°n')
        
        # 2. Heatmap TC theo instance v√† thu·∫≠t to√°n
        ax2 = axes[0, 1]
        pivot_tc = self.df_clean.pivot_table(values='TC_Mean', index='Instance', 
                                           columns='Algorithm', aggfunc='mean')
        sns.heatmap(pivot_tc, annot=True, fmt='.0f', cmap='Reds', ax=ax2)
        ax2.set_title('üí∞ Chi ph√≠ t·ªïng theo Instance & Thu·∫≠t to√°n')
        
        # 3. Bi·ªÉu ƒë·ªì c·ªôt nh√≥m - NV v√† TC theo instance
        ax3 = axes[1, 0]
        instance_stats = self.df_clean.groupby('Instance').agg({
            'NV_Mean': 'mean',
            'TC_Mean': 'mean'
        })
        
        x = np.arange(len(instances))
        width = 0.35
        
        # Chu·∫©n h√≥a TC ƒë·ªÉ hi·ªÉn th·ªã c√πng v·ªõi NV
        tc_normalized = instance_stats['TC_Mean'] / instance_stats['TC_Mean'].max() * instance_stats['NV_Mean'].max()
        
        bars1 = ax3.bar(x - width/2, instance_stats['NV_Mean'], width, 
                       label='S·ªë xe TB', color='skyblue')
        bars2 = ax3.bar(x + width/2, tc_normalized, width, 
                       label='Chi ph√≠ TB (chu·∫©n h√≥a)', color='lightcoral')
        
        ax3.set_title('üìä So s√°nh NV v√† TC theo Instance')
        ax3.set_xlabel('Instance')
        ax3.set_ylabel('Gi√° tr·ªã')
        ax3.set_xticks(x)
        ax3.set_xticklabels(instances, rotation=45)
        ax3.legend()
        
        # 4. Scatter plot: ƒê·ªô kh√≥ instance d·ª±a tr√™n NV-TC
        ax4 = axes[1, 1]
        instance_difficulty = self.df_clean.groupby('Instance').agg({
            'NV_Mean': 'mean',
            'TC_Mean': 'mean'
        })
        
        scatter = ax4.scatter(instance_difficulty['NV_Mean'], instance_difficulty['TC_Mean'], 
                            s=100, alpha=0.7, c=range(len(instance_difficulty)), 
                            cmap='viridis')
        
        # Th√™m label cho t·ª´ng ƒëi·ªÉm
        for i, instance in enumerate(instance_difficulty.index):
            ax4.annotate(instance, 
                        (instance_difficulty.iloc[i]['NV_Mean'], 
                         instance_difficulty.iloc[i]['TC_Mean']),
                        xytext=(5, 5), textcoords='offset points', fontsize=9)
        
        ax4.set_title('üéØ ƒê·ªô kh√≥ Instance (NV vs TC)')
        ax4.set_xlabel('S·ªë xe trung b√¨nh')
        ax4.set_ylabel('Chi ph√≠ t·ªïng trung b√¨nh')
        ax4.grid(True, alpha=0.3)
        
        plt.tight_layout()
        
        if save_fig:
            filename = "nv_tc_instance_analysis.png"
            plt.savefig(filename, dpi=300, bbox_inches='tight')
            print(f"üíæ ƒê√£ l∆∞u bi·ªÉu ƒë·ªì: {filename}")
        
        plt.show()
    
    def generate_nv_tc_summary_report(self):
        """
        T·∫°o b√°o c√°o t·ªïng h·ª£p cho NV v√† TC
        """
        if not self.check_data_availability():
            return
        print("="*60)
        print("üöõüí∞ B√ÅO C√ÅO T·ªîNG H·ª¢P K·∫æT QU·∫¢ NV-TC")
        print("="*60)
        
        print(f"\nüìà TH·ªêNG K√ä T·ªîNG QUAN:")
        print(f"   ‚Ä¢ T·ªïng s·ªë th√≠ nghi·ªám: {len(self.df_clean)}")
        print(f"   ‚Ä¢ S·ªë instance: {len(self.df_clean['Instance'].unique())}")
        print(f"   ‚Ä¢ S·ªë thu·∫≠t to√°n: {len(self.df_clean['Algorithm'].unique())}")
        
        print(f"\nüèÜ THU·∫¨T TO√ÅN T·ªêT NH·∫§T THEO T·ª™NG CH·ªà S·ªê:")
        
        # S·ªë xe √≠t nh·∫•t
        best_nv = self.df_clean.loc[self.df_clean['NV_Mean'].idxmin()]
        print(f"   ‚Ä¢ S·ªë xe √≠t nh·∫•t: {best_nv['Algorithm']} ({best_nv['NV_Mean']:.1f}) - Instance: {best_nv['Instance']}")
        
        # Chi ph√≠ th·∫•p nh·∫•t
        best_tc = self.df_clean.loc[self.df_clean['TC_Mean'].idxmin()]
        print(f"   ‚Ä¢ Chi ph√≠ th·∫•p nh·∫•t: {best_tc['Algorithm']} ({best_tc['TC_Mean']:.2f}) - Instance: {best_tc['Instance']}")
        
        print(f"\nüìä TH·ªêNG K√ä THEO THU·∫¨T TO√ÅN:")
        alg_stats = self.df_clean.groupby('Algorithm').agg({
            'NV_Mean': ['mean', 'std', 'min', 'max'],
            'TC_Mean': ['mean', 'std', 'min', 'max']
        }).round(2)
        
        for alg in self.df_clean['Algorithm'].unique():
            print(f"\n   üîß {alg}:")
            print(f"      - S·ªë xe TB: {alg_stats.loc[alg, ('NV_Mean', 'mean')]:.1f} ¬± {alg_stats.loc[alg, ('NV_Mean', 'std')]:.1f}")
            print(f"      - Chi ph√≠ TB: {alg_stats.loc[alg, ('TC_Mean', 'mean')]:.2f} ¬± {alg_stats.loc[alg, ('TC_Mean', 'std')]:.2f}")
        
        print(f"\nüìã TH·ªêNG K√ä THEO INSTANCE:")
        instance_stats = self.df_clean.groupby('Instance').agg({
            'NV_Mean': ['mean', 'std'],
            'TC_Mean': ['mean', 'std']
        }).round(2)
        
        for instance in self.df_clean['Instance'].unique():
            print(f"\n   üìÑ {instance}:")
            print(f"      - S·ªë xe TB: {instance_stats.loc[instance, ('NV_Mean', 'mean')]:.1f} ¬± {instance_stats.loc[instance, ('NV_Mean', 'std')]:.1f}")
            print(f"      - Chi ph√≠ TB: {instance_stats.loc[instance, ('TC_Mean', 'mean')]:.2f} ¬± {instance_stats.loc[instance, ('TC_Mean', 'std')]:.2f}")
        
        # T∆∞∆°ng quan NV-TC
        correlation = self.df_clean['NV_Mean'].corr(self.df_clean['TC_Mean'])
        print(f"\nüîó T∆Ø∆†NG QUAN NV-TC: {correlation:.3f}")
        if correlation > 0.7:
            print("   ‚Üí T∆∞∆°ng quan d∆∞∆°ng m·∫°nh: S·ªë xe tƒÉng th√¨ chi ph√≠ tƒÉng")
        elif correlation > 0.3:
            print("   ‚Üí T∆∞∆°ng quan d∆∞∆°ng trung b√¨nh")
        elif correlation > -0.3:
            print("   ‚Üí T∆∞∆°ng quan y·∫øu")
        else:
            print("   ‚Üí T∆∞∆°ng quan √¢m: S·ªë xe tƒÉng th√¨ chi ph√≠ gi·∫£m")
        
        print("\n" + "="*60)
    
    def create_nv_tc_dashboard(self):
        """
        T·∫°o dashboard t·ªïng h·ª£p cho NV v√† TC
        """
        print("üöÄ ƒêang t·∫°o dashboard NV-TC...")
        
        # T·∫°o b√°o c√°o t·ªïng h·ª£p
        self.generate_nv_tc_summary_report()
        
        # T·∫°o c√°c bi·ªÉu ƒë·ªì
        print("\nüìä ƒêang t·∫°o bi·ªÉu ƒë·ªì ph√¢n t√≠ch hi·ªáu su·∫•t NV-TC...")
        self.plot_algorithm_nv_tc_performance()
        
        print("\nüìã ƒêang t·∫°o bi·ªÉu ƒë·ªì ph√¢n t√≠ch NV-TC theo instance...")
        self.plot_instance_nv_tc_analysis()
        
        print("\nüìà ƒêang t·∫°o bi·ªÉu ƒë·ªì so s√°nh NV-TC...")
        self.plot_nv_tc_comparison()
        
        print("\n‚úÖ Ho√†n th√†nh t·∫°o dashboard NV-TC!")

# S·ª≠ d·ª•ng l·ªõp NV_TC_ResultsVisualizer
if __name__ == "__main__":
    # Kh·ªüi t·∫°o visualizer
    visualizer = NV_TC_ResultsVisualizer()
    
    # T·∫°o dashboard t·ªïng h·ª£p NV-TC
    visualizer.create_nv_tc_dashboard()
    
    # V√≠ d·ª• s·ª≠ d·ª•ng c√°c h√†m ri√™ng l·∫ª
    # visualizer.plot_nv_tc_comparison("c101.txt")        # So s√°nh NV-TC cho instance c·ª• th·ªÉ
    # visualizer.plot_algorithm_nv_tc_performance()       # Ph√¢n t√≠ch hi·ªáu su·∫•t NV-TC thu·∫≠t to√°n
    # visualizer.plot_instance_nv_tc_analysis()           # Ph√¢n t√≠ch NV-TC theo instance